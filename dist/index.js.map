{"version":3,"sources":["../src/lib/cache.ts"],"names":[],"mappings":";;;AAcA,IAAM,KAAA,GAAQ,CACb,EAAA,EACA,EAAE,OAAA,GAAU,KAAK,SAAW,EAAA,GAAA,EAAsB,GAAA,EACjC,KAAA;AACjB,EAAM,MAAA,OAAA,GAAU,IAAI,UAAA,CAAmD,OAAO,CAAA;AAC9E,EAAM,MAAA,OAAA,uBAAc,GAAwB,EAAA;AAE5C,EAAM,MAAA,QAAA,GAAwB,OAAO,UAAe,KAAA;AACnD,IAAA,MAAM,GAAM,GAAA,SAAA,GAAY,SAAU,CAAA,UAAU,CAAI,GAAA,UAAA;AAEhD,IAAM,MAAA,KAAA,GAAQ,OAAQ,CAAA,GAAA,CAAI,GAAG,CAAA;AAE7B,IAAA,IAAI,UAAU,KAAW,CAAA,EAAA;AACxB,MAAM,MAAA,EAAE,KAAO,EAAA,OAAA,EAAY,GAAA,KAAA;AAE3B,MAAA,IAAI,OAAY,KAAA,KAAA,CAAA,IAAa,IAAK,CAAA,GAAA,KAAQ,OAAS,EAAA;AAClD,QAAO,OAAA,KAAA;AAAA,OACD,MAAA;AACN,QAAA,OAAA,CAAQ,OAAO,GAAG,CAAA;AAAA;AACnB;AAGD,IAAI,IAAA,OAAA,CAAQ,GAAI,CAAA,GAAG,CAAG,EAAA;AACrB,MAAO,OAAA,OAAA,CAAQ,IAAI,GAAG,CAAA;AAAA;AAGvB,IAAA,MAAM,UAAU,EAAG,CAAA,GAAG,CACpB,CAAA,IAAA,CAAK,CAAC,KAAU,KAAA;AAChB,MAAA,OAAA,CAAQ,IAAI,GAAK,EAAA;AAAA,QAChB,KAAA;AAAA,QACA,OAAS,EAAA,GAAA,GAAM,IAAK,CAAA,GAAA,KAAQ,GAAM,GAAA,KAAA;AAAA,OAClC,CAAA;AAED,MAAO,OAAA,KAAA;AAAA,KACP,CAAA,CACA,KAAM,CAAA,CAAC,KAAU,KAAA;AACjB,MAAM,MAAA,KAAA;AAAA,KACN,CACA,CAAA,OAAA,CAAQ,MAAM;AACd,MAAA,OAAA,CAAQ,OAAO,GAAG,CAAA;AAAA,KAClB,CAAA;AAEF,IAAQ,OAAA,CAAA,GAAA,CAAI,KAAK,OAAO,CAAA;AAExB,IAAO,OAAA,OAAA;AAAA,GACR;AAEA,EAAS,QAAA,CAAA,KAAA,GAAQ,CAAC,YAAwB,KAAA;AACzC,IAAA,OAAA,CAAQ,KAAM,EAAA;AAEd,IAAA,IAAI,iBAAiB,IAAM,EAAA;AAC1B,MAAA,OAAA,CAAQ,KAAM,EAAA;AAAA;AACf,GACD;AAEA,EAAS,QAAA,CAAA,UAAA,GAAa,CAAC,GAAgB,KAAA;AACtC,IAAA,OAAA,CAAQ,OAAO,GAAG,CAAA;AAAA,GACnB;AAEA,EAAO,OAAA,QAAA;AACR,CAAA;AAEA,IAAO,aAAQ,GAAA","file":"index.js","sourcesContent":["import type { CachedFn, CacheOptions } from '$types/cache.js';\nimport { SieveCache } from '@neophi/sieve-cache';\n\n/**\n * Creates a cached version of the provided asynchronous function.\n *\n * @template T - The type of the value returned by the function.\n * @param {function(string): Promise<T>} fn - The asynchronous function to be cached.\n * @param {Object} [options] - Optional configuration for the cache.\n * @param {number} [options.maxSize=255] - The maximum number of entries in the cache.\n * @param {function(string): string} [options.serialize] - A function to serialize the cache keys.\n * @param {number} [options.ttl] - Time-to-live for cache entries in milliseconds.\n * @returns {CachedFn<T>} - The cached version of the provided function.\n */\nconst cache = <T>(\n\tfn: (key: string) => Promise<T>,\n\t{ maxSize = 255, serialize, ttl }: CacheOptions = {}\n): CachedFn<T> => {\n\tconst entries = new SieveCache<string, { value: T; expires?: number }>(maxSize);\n\tconst pending = new Map<string, Promise<T>>();\n\n\tconst cachedFn: CachedFn<T> = async (naturalKey) => {\n\t\tconst key = serialize ? serialize(naturalKey) : naturalKey;\n\n\t\tconst entry = entries.get(key);\n\n\t\tif (entry !== undefined) {\n\t\t\tconst { value, expires } = entry;\n\n\t\t\tif (expires === undefined || Date.now() < expires) {\n\t\t\t\treturn value;\n\t\t\t} else {\n\t\t\t\tentries.delete(key);\n\t\t\t}\n\t\t}\n\n\t\tif (pending.has(key)) {\n\t\t\treturn pending.get(key) as Promise<T>;\n\t\t}\n\n\t\tconst promise = fn(key)\n\t\t\t.then((value) => {\n\t\t\t\tentries.set(key, {\n\t\t\t\t\tvalue,\n\t\t\t\t\texpires: ttl ? Date.now() + ttl : undefined\n\t\t\t\t});\n\n\t\t\t\treturn value;\n\t\t\t})\n\t\t\t.catch((error) => {\n\t\t\t\tthrow error;\n\t\t\t})\n\t\t\t.finally(() => {\n\t\t\t\tpending.delete(key);\n\t\t\t});\n\n\t\tpending.set(key, promise);\n\n\t\treturn promise;\n\t};\n\n\tcachedFn.clear = (clearPending?: true) => {\n\t\tentries.clear();\n\n\t\tif (clearPending === true) {\n\t\t\tpending.clear();\n\t\t}\n\t};\n\n\tcachedFn.invalidate = (key: string) => {\n\t\tentries.delete(key);\n\t};\n\n\treturn cachedFn;\n};\n\nexport default cache;\n"]}